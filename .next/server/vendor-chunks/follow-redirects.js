"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/follow-redirects";
exports.ids = ["vendor-chunks/follow-redirects"];
exports.modules = {

/***/ "(rsc)/./node_modules/follow-redirects/debug.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/debug.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar debug;\nmodule.exports = function() {\n    if (!debug) {\n        try {\n            /* eslint global-require: off */ debug = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\")(\"follow-redirects\");\n        } catch (error) {}\n        if (typeof debug !== \"function\") {\n            debug = function() {};\n        }\n    }\n    debug.apply(null, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsSUFBSUE7QUFFSkMsT0FBT0MsT0FBTyxHQUFHO0lBQ2YsSUFBSSxDQUFDRixPQUFPO1FBQ1YsSUFBSTtZQUNGLDhCQUE4QixHQUM5QkEsUUFBUUcsbUJBQU9BLENBQUMsc0RBQU8sRUFBRTtRQUMzQixFQUNBLE9BQU9DLE9BQU8sQ0FBUTtRQUN0QixJQUFJLE9BQU9KLFVBQVUsWUFBWTtZQUMvQkEsUUFBUSxZQUFvQjtRQUM5QjtJQUNGO0lBQ0FBLE1BQU1LLEtBQUssQ0FBQyxNQUFNQztBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Rldl9maW5kZXIvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9kZWJ1Zy5qcz8yNTgxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWJ1ZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghZGVidWcpIHtcbiAgICB0cnkge1xuICAgICAgLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiBvZmYgKi9cbiAgICAgIGRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpKFwiZm9sbG93LXJlZGlyZWN0c1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IC8qICovIH1cbiAgICBpZiAodHlwZW9mIGRlYnVnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRlYnVnID0gZnVuY3Rpb24gKCkgeyAvKiAqLyB9O1xuICAgIH1cbiAgfVxuICBkZWJ1Zy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbiJdLCJuYW1lcyI6WyJkZWJ1ZyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiZXJyb3IiLCJhcHBseSIsImFyZ3VtZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/follow-redirects/debug.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/follow-redirects/index.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar url = __webpack_require__(/*! url */ \"url\");\nvar URL = url.URL;\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar Writable = (__webpack_require__(/*! stream */ \"stream\").Writable);\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar debug = __webpack_require__(/*! ./debug */ \"(rsc)/./node_modules/follow-redirects/debug.js\");\n// Create handlers that pass events from native requests\nvar events = [\n    \"abort\",\n    \"aborted\",\n    \"connect\",\n    \"error\",\n    \"socket\",\n    \"timeout\"\n];\nvar eventHandlers = Object.create(null);\nevents.forEach(function(event) {\n    eventHandlers[event] = function(arg1, arg2, arg3) {\n        this._redirectable.emit(event, arg1, arg2, arg3);\n    };\n});\nvar InvalidUrlError = createErrorType(\"ERR_INVALID_URL\", \"Invalid URL\", TypeError);\n// Error types with codes\nvar RedirectionError = createErrorType(\"ERR_FR_REDIRECTION_FAILURE\", \"Redirected request failed\");\nvar TooManyRedirectsError = createErrorType(\"ERR_FR_TOO_MANY_REDIRECTS\", \"Maximum number of redirects exceeded\");\nvar MaxBodyLengthExceededError = createErrorType(\"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\", \"Request body larger than maxBodyLength limit\");\nvar WriteAfterEndError = createErrorType(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\");\n// istanbul ignore next\nvar destroy = Writable.prototype.destroy || noop;\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n    // Initialize the request\n    Writable.call(this);\n    this._sanitizeOptions(options);\n    this._options = options;\n    this._ended = false;\n    this._ending = false;\n    this._redirectCount = 0;\n    this._redirects = [];\n    this._requestBodyLength = 0;\n    this._requestBodyBuffers = [];\n    // Attach a callback if passed\n    if (responseCallback) {\n        this.on(\"response\", responseCallback);\n    }\n    // React to responses of native requests\n    var self = this;\n    this._onNativeResponse = function(response) {\n        self._processResponse(response);\n    };\n    // Perform the first request\n    this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\nRedirectableRequest.prototype.abort = function() {\n    destroyRequest(this._currentRequest);\n    this._currentRequest.abort();\n    this.emit(\"abort\");\n};\nRedirectableRequest.prototype.destroy = function(error) {\n    destroyRequest(this._currentRequest, error);\n    destroy.call(this, error);\n    return this;\n};\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function(data, encoding, callback) {\n    // Writing is not allowed if end has been called\n    if (this._ending) {\n        throw new WriteAfterEndError();\n    }\n    // Validate input and shift parameters if necessary\n    if (!isString(data) && !isBuffer(data)) {\n        throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n    }\n    if (isFunction(encoding)) {\n        callback = encoding;\n        encoding = null;\n    }\n    // Ignore empty buffers, since writing them doesn't invoke the callback\n    // https://github.com/nodejs/node/issues/22066\n    if (data.length === 0) {\n        if (callback) {\n            callback();\n        }\n        return;\n    }\n    // Only write when we don't exceed the maximum body length\n    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n        this._requestBodyLength += data.length;\n        this._requestBodyBuffers.push({\n            data: data,\n            encoding: encoding\n        });\n        this._currentRequest.write(data, encoding, callback);\n    } else {\n        this.emit(\"error\", new MaxBodyLengthExceededError());\n        this.abort();\n    }\n};\n// Ends the current native request\nRedirectableRequest.prototype.end = function(data, encoding, callback) {\n    // Shift parameters if necessary\n    if (isFunction(data)) {\n        callback = data;\n        data = encoding = null;\n    } else if (isFunction(encoding)) {\n        callback = encoding;\n        encoding = null;\n    }\n    // Write data if needed and end\n    if (!data) {\n        this._ended = this._ending = true;\n        this._currentRequest.end(null, null, callback);\n    } else {\n        var self = this;\n        var currentRequest = this._currentRequest;\n        this.write(data, encoding, function() {\n            self._ended = true;\n            currentRequest.end(null, null, callback);\n        });\n        this._ending = true;\n    }\n};\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function(name, value) {\n    this._options.headers[name] = value;\n    this._currentRequest.setHeader(name, value);\n};\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function(name) {\n    delete this._options.headers[name];\n    this._currentRequest.removeHeader(name);\n};\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function(msecs, callback) {\n    var self = this;\n    // Destroys the socket on timeout\n    function destroyOnTimeout(socket) {\n        socket.setTimeout(msecs);\n        socket.removeListener(\"timeout\", socket.destroy);\n        socket.addListener(\"timeout\", socket.destroy);\n    }\n    // Sets up a timer to trigger a timeout event\n    function startTimer(socket) {\n        if (self._timeout) {\n            clearTimeout(self._timeout);\n        }\n        self._timeout = setTimeout(function() {\n            self.emit(\"timeout\");\n            clearTimer();\n        }, msecs);\n        destroyOnTimeout(socket);\n    }\n    // Stops a timeout from triggering\n    function clearTimer() {\n        // Clear the timeout\n        if (self._timeout) {\n            clearTimeout(self._timeout);\n            self._timeout = null;\n        }\n        // Clean up all attached listeners\n        self.removeListener(\"abort\", clearTimer);\n        self.removeListener(\"error\", clearTimer);\n        self.removeListener(\"response\", clearTimer);\n        self.removeListener(\"close\", clearTimer);\n        if (callback) {\n            self.removeListener(\"timeout\", callback);\n        }\n        if (!self.socket) {\n            self._currentRequest.removeListener(\"socket\", startTimer);\n        }\n    }\n    // Attach callback if passed\n    if (callback) {\n        this.on(\"timeout\", callback);\n    }\n    // Start the timer if or when the socket is opened\n    if (this.socket) {\n        startTimer(this.socket);\n    } else {\n        this._currentRequest.once(\"socket\", startTimer);\n    }\n    // Clean up on events\n    this.on(\"socket\", destroyOnTimeout);\n    this.on(\"abort\", clearTimer);\n    this.on(\"error\", clearTimer);\n    this.on(\"response\", clearTimer);\n    this.on(\"close\", clearTimer);\n    return this;\n};\n// Proxy all other public ClientRequest methods\n[\n    \"flushHeaders\",\n    \"getHeader\",\n    \"setNoDelay\",\n    \"setSocketKeepAlive\"\n].forEach(function(method) {\n    RedirectableRequest.prototype[method] = function(a, b) {\n        return this._currentRequest[method](a, b);\n    };\n});\n// Proxy all public ClientRequest properties\n[\n    \"aborted\",\n    \"connection\",\n    \"socket\"\n].forEach(function(property) {\n    Object.defineProperty(RedirectableRequest.prototype, property, {\n        get: function() {\n            return this._currentRequest[property];\n        }\n    });\n});\nRedirectableRequest.prototype._sanitizeOptions = function(options) {\n    // Ensure headers are always present\n    if (!options.headers) {\n        options.headers = {};\n    }\n    // Since http.request treats host as an alias of hostname,\n    // but the url module interprets host as hostname plus port,\n    // eliminate the host property to avoid confusion.\n    if (options.host) {\n        // Use hostname if set, because it has precedence\n        if (!options.hostname) {\n            options.hostname = options.host;\n        }\n        delete options.host;\n    }\n    // Complete the URL object when necessary\n    if (!options.pathname && options.path) {\n        var searchPos = options.path.indexOf(\"?\");\n        if (searchPos < 0) {\n            options.pathname = options.path;\n        } else {\n            options.pathname = options.path.substring(0, searchPos);\n            options.search = options.path.substring(searchPos);\n        }\n    }\n};\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function() {\n    // Load the native protocol\n    var protocol = this._options.protocol;\n    var nativeProtocol = this._options.nativeProtocols[protocol];\n    if (!nativeProtocol) {\n        this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n        return;\n    }\n    // If specified, use the agent corresponding to the protocol\n    // (HTTP and HTTPS use different types of agents)\n    if (this._options.agents) {\n        var scheme = protocol.slice(0, -1);\n        this._options.agent = this._options.agents[scheme];\n    }\n    // Create the native request and set up its event handlers\n    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);\n    request._redirectable = this;\n    for (var event of events){\n        request.on(event, eventHandlers[event]);\n    }\n    // RFC7230§5.3.1: When making a request directly to an origin server, […]\n    // a client MUST send only the absolute path […] as the request-target.\n    this._currentUrl = /^\\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, […]\n    // a client MUST send the target URI in absolute-form […].\n    this._options.path;\n    // End a redirected request\n    // (The first request must be ended explicitly with RedirectableRequest#end)\n    if (this._isRedirect) {\n        // Write the request entity and end\n        var i = 0;\n        var self = this;\n        var buffers = this._requestBodyBuffers;\n        (function writeNext(error) {\n            // Only write if this request has not been redirected yet\n            /* istanbul ignore else */ if (request === self._currentRequest) {\n                // Report any write errors\n                /* istanbul ignore if */ if (error) {\n                    self.emit(\"error\", error);\n                } else if (i < buffers.length) {\n                    var buffer = buffers[i++];\n                    /* istanbul ignore else */ if (!request.finished) {\n                        request.write(buffer.data, buffer.encoding, writeNext);\n                    }\n                } else if (self._ended) {\n                    request.end();\n                }\n            }\n        })();\n    }\n};\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function(response) {\n    // Store the redirected response\n    var statusCode = response.statusCode;\n    if (this._options.trackRedirects) {\n        this._redirects.push({\n            url: this._currentUrl,\n            headers: response.headers,\n            statusCode: statusCode\n        });\n    }\n    // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n    // that further action needs to be taken by the user agent in order to\n    // fulfill the request. If a Location header field is provided,\n    // the user agent MAY automatically redirect its request to the URI\n    // referenced by the Location field value,\n    // even if the specific status code is not understood.\n    // If the response is not a redirect; return it as-is\n    var location = response.headers.location;\n    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {\n        response.responseUrl = this._currentUrl;\n        response.redirects = this._redirects;\n        this.emit(\"response\", response);\n        // Clean up\n        this._requestBodyBuffers = [];\n        return;\n    }\n    // The response is a redirect, so abort the current request\n    destroyRequest(this._currentRequest);\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n    // RFC7231§6.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n        this.emit(\"error\", new TooManyRedirectsError());\n        return;\n    }\n    // Store the request headers if applicable\n    var requestHeaders;\n    var beforeRedirect = this._options.beforeRedirect;\n    if (beforeRedirect) {\n        requestHeaders = Object.assign({\n            // The Host header was set by nativeProtocol.request\n            Host: response.req.getHeader(\"host\")\n        }, this._options.headers);\n    }\n    // RFC7231§6.4: Automatic redirection needs to done with\n    // care for methods not known to be safe, […]\n    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\n    // the request method from POST to GET for the subsequent request.\n    var method = this._options.method;\n    if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that\n    // the server is redirecting the user agent to a different resource […]\n    // A user agent can perform a retrieval request targeting that URI\n    // (a GET or HEAD request if using HTTP) […]\n    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n        this._options.method = \"GET\";\n        // Drop a possible entity and headers related to it\n        this._requestBodyBuffers = [];\n        removeMatchingHeaders(/^content-/i, this._options.headers);\n    }\n    // Drop the Host header, as the redirect might lead to a different host\n    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n    // If the redirect is relative, carry over the host of the last request\n    var currentUrlParts = url.parse(this._currentUrl);\n    var currentHost = currentHostHeader || currentUrlParts.host;\n    var currentUrl = /^\\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {\n        host: currentHost\n    }));\n    // Determine the URL of the redirection\n    var redirectUrl;\n    try {\n        redirectUrl = url.resolve(currentUrl, location);\n    } catch (cause) {\n        this.emit(\"error\", new RedirectionError({\n            cause: cause\n        }));\n        return;\n    }\n    // Create the redirected request\n    debug(\"redirecting to\", redirectUrl);\n    this._isRedirect = true;\n    var redirectUrlParts = url.parse(redirectUrl);\n    Object.assign(this._options, redirectUrlParts);\n    // Drop confidential headers when redirecting to a less secure protocol\n    // or to a different domain that is not a superdomain\n    if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== \"https:\" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {\n        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);\n    }\n    // Evaluate the beforeRedirect callback\n    if (isFunction(beforeRedirect)) {\n        var responseDetails = {\n            headers: response.headers,\n            statusCode: statusCode\n        };\n        var requestDetails = {\n            url: currentUrl,\n            method: method,\n            headers: requestHeaders\n        };\n        try {\n            beforeRedirect(this._options, responseDetails, requestDetails);\n        } catch (err) {\n            this.emit(\"error\", err);\n            return;\n        }\n        this._sanitizeOptions(this._options);\n    }\n    // Perform the redirected request\n    try {\n        this._performRequest();\n    } catch (cause) {\n        this.emit(\"error\", new RedirectionError({\n            cause: cause\n        }));\n    }\n};\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n    // Default settings\n    var exports = {\n        maxRedirects: 21,\n        maxBodyLength: 10 * 1024 * 1024\n    };\n    // Wrap each protocol\n    var nativeProtocols = {};\n    Object.keys(protocols).forEach(function(scheme) {\n        var protocol = scheme + \":\";\n        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n        var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n        // Executes a request, following redirects\n        function request(input, options, callback) {\n            // Parse parameters\n            if (isString(input)) {\n                var parsed;\n                try {\n                    parsed = urlToOptions(new URL(input));\n                } catch (err) {\n                    /* istanbul ignore next */ parsed = url.parse(input);\n                }\n                if (!isString(parsed.protocol)) {\n                    throw new InvalidUrlError({\n                        input\n                    });\n                }\n                input = parsed;\n            } else if (URL && input instanceof URL) {\n                input = urlToOptions(input);\n            } else {\n                callback = options;\n                options = input;\n                input = {\n                    protocol: protocol\n                };\n            }\n            if (isFunction(options)) {\n                callback = options;\n                options = null;\n            }\n            // Set defaults\n            options = Object.assign({\n                maxRedirects: exports.maxRedirects,\n                maxBodyLength: exports.maxBodyLength\n            }, input, options);\n            options.nativeProtocols = nativeProtocols;\n            if (!isString(options.host) && !isString(options.hostname)) {\n                options.hostname = \"::1\";\n            }\n            assert.equal(options.protocol, protocol, \"protocol mismatch\");\n            debug(\"options\", options);\n            return new RedirectableRequest(options, callback);\n        }\n        // Executes a GET request, following redirects\n        function get(input, options, callback) {\n            var wrappedRequest = wrappedProtocol.request(input, options, callback);\n            wrappedRequest.end();\n            return wrappedRequest;\n        }\n        // Expose the properties on the wrapped protocol\n        Object.defineProperties(wrappedProtocol, {\n            request: {\n                value: request,\n                configurable: true,\n                enumerable: true,\n                writable: true\n            },\n            get: {\n                value: get,\n                configurable: true,\n                enumerable: true,\n                writable: true\n            }\n        });\n    });\n    return exports;\n}\n/* istanbul ignore next */ function noop() {}\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\nfunction urlToOptions(urlObject) {\n    var options = {\n        protocol: urlObject.protocol,\n        hostname: urlObject.hostname.startsWith(\"[\") ? /* istanbul ignore next */ urlObject.hostname.slice(1, -1) : urlObject.hostname,\n        hash: urlObject.hash,\n        search: urlObject.search,\n        pathname: urlObject.pathname,\n        path: urlObject.pathname + urlObject.search,\n        href: urlObject.href\n    };\n    if (urlObject.port !== \"\") {\n        options.port = Number(urlObject.port);\n    }\n    return options;\n}\nfunction removeMatchingHeaders(regex, headers) {\n    var lastValue;\n    for(var header in headers){\n        if (regex.test(header)) {\n            lastValue = headers[header];\n            delete headers[header];\n        }\n    }\n    return lastValue === null || typeof lastValue === \"undefined\" ? undefined : String(lastValue).trim();\n}\nfunction createErrorType(code, message, baseClass) {\n    // Create constructor\n    function CustomError(properties) {\n        Error.captureStackTrace(this, this.constructor);\n        Object.assign(this, properties || {});\n        this.code = code;\n        this.message = this.cause ? message + \": \" + this.cause.message : message;\n    }\n    // Attach constructor and set default properties\n    CustomError.prototype = new (baseClass || Error)();\n    CustomError.prototype.constructor = CustomError;\n    CustomError.prototype.name = \"Error [\" + code + \"]\";\n    return CustomError;\n}\nfunction destroyRequest(request, error) {\n    for (var event of events){\n        request.removeListener(event, eventHandlers[event]);\n    }\n    request.on(\"error\", noop);\n    request.destroy(error);\n}\nfunction isSubdomain(subdomain, domain) {\n    assert(isString(subdomain) && isString(domain));\n    var dot = subdomain.length - domain.length - 1;\n    return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\nfunction isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n}\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\nfunction isBuffer(value) {\n    return typeof value === \"object\" && \"length\" in value;\n}\n// Exports\nmodule.exports = wrap({\n    http: http,\n    https: https\n});\nmodule.exports.wrap = wrap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsSUFBSUEsTUFBTUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDdkIsSUFBSUMsTUFBTUYsSUFBSUUsR0FBRztBQUNqQixJQUFJQyxPQUFPRixtQkFBT0EsQ0FBQyxrQkFBTTtBQUN6QixJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQyxvQkFBTztBQUMzQixJQUFJSSxXQUFXSixzREFBMEI7QUFDekMsSUFBSUssU0FBU0wsbUJBQU9BLENBQUMsc0JBQVE7QUFDN0IsSUFBSU0sUUFBUU4sbUJBQU9BLENBQUMsK0RBQVM7QUFFN0Isd0RBQXdEO0FBQ3hELElBQUlPLFNBQVM7SUFBQztJQUFTO0lBQVc7SUFBVztJQUFTO0lBQVU7Q0FBVTtBQUMxRSxJQUFJQyxnQkFBZ0JDLE9BQU9DLE1BQU0sQ0FBQztBQUNsQ0gsT0FBT0ksT0FBTyxDQUFDLFNBQVVDLEtBQUs7SUFDNUJKLGFBQWEsQ0FBQ0ksTUFBTSxHQUFHLFNBQVVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJO1FBQy9DLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUNMLE9BQU9DLE1BQU1DLE1BQU1DO0lBQzdDO0FBQ0Y7QUFFQSxJQUFJRyxrQkFBa0JDLGdCQUNwQixtQkFDQSxlQUNBQztBQUVGLHlCQUF5QjtBQUN6QixJQUFJQyxtQkFBbUJGLGdCQUNyQiw4QkFDQTtBQUVGLElBQUlHLHdCQUF3QkgsZ0JBQzFCLDZCQUNBO0FBRUYsSUFBSUksNkJBQTZCSixnQkFDL0IsbUNBQ0E7QUFFRixJQUFJSyxxQkFBcUJMLGdCQUN2Qiw4QkFDQTtBQUdGLHVCQUF1QjtBQUN2QixJQUFJTSxVQUFVckIsU0FBU3NCLFNBQVMsQ0FBQ0QsT0FBTyxJQUFJRTtBQUU1Qyw0Q0FBNEM7QUFDNUMsU0FBU0Msb0JBQW9CQyxPQUFPLEVBQUVDLGdCQUFnQjtJQUNwRCx5QkFBeUI7SUFDekIxQixTQUFTMkIsSUFB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QUswSSxDQUFBQSxhQUFhRyxLQUFJO0lBQzlDRixZQUFZM0ksU0FBUyxDQUFDK0ksV0FBVyxHQUFHSjtJQUNwQ0EsWUFBWTNJLFNBQVMsQ0FBQ3FDLElBQUksR0FBRyxZQUFZbUcsT0FBTztJQUNoRCxPQUFPRztBQUNUO0FBRUEsU0FBU3RILGVBQWVvRCxPQUFPLEVBQUVsRCxLQUFLO0lBQ3BDLEtBQUssSUFBSXJDLFNBQVNMLE9BQVE7UUFDeEI0RixRQUFRNUIsY0FBYyxDQUFDM0QsT0FBT0osYUFBYSxDQUFDSSxNQUFNO0lBQ3BEO0lBQ0F1RixRQUFRM0QsRUFBRSxDQUFDLFNBQVNiO0lBQ3BCd0UsUUFBUTFFLE9BQU8sQ0FBQ3dCO0FBQ2xCO0FBRUEsU0FBU21GLFlBQVlzQyxTQUFTLEVBQUVDLE1BQU07SUFDcEN0SyxPQUFPaUQsU0FBU29ILGNBQWNwSCxTQUFTcUg7SUFDdkMsSUFBSUMsTUFBTUYsVUFBVWpILE1BQU0sR0FBR2tILE9BQU9sSCxNQUFNLEdBQUc7SUFDN0MsT0FBT21ILE1BQU0sS0FBS0YsU0FBUyxDQUFDRSxJQUFJLEtBQUssT0FBT0YsVUFBVUcsUUFBUSxDQUFDRjtBQUNqRTtBQUVBLFNBQVNySCxTQUFTVSxLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxpQkFBaUJnRztBQUN2RDtBQUVBLFNBQVN4RyxXQUFXUSxLQUFLO0lBQ3ZCLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVBLFNBQVNULFNBQVNTLEtBQUs7SUFDckIsT0FBTyxPQUFPQSxVQUFVLFlBQWEsWUFBWUE7QUFDbkQ7QUFFQSxVQUFVO0FBQ1Y4RyxPQUFPcEMsT0FBTyxHQUFHRixLQUFLO0lBQUV0SSxNQUFNQTtJQUFNQyxPQUFPQTtBQUFNO0FBQ2pEMkssbUJBQW1CLEdBQUd0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rldl9maW5kZXIvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9pbmRleC5qcz85NGIyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xudmFyIFVSTCA9IHVybC5VUkw7XG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xudmFyIGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZShcInN0cmVhbVwiKS5Xcml0YWJsZTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIGRlYnVnID0gcmVxdWlyZShcIi4vZGVidWdcIik7XG5cbi8vIENyZWF0ZSBoYW5kbGVycyB0aGF0IHBhc3MgZXZlbnRzIGZyb20gbmF0aXZlIHJlcXVlc3RzXG52YXIgZXZlbnRzID0gW1wiYWJvcnRcIiwgXCJhYm9ydGVkXCIsIFwiY29ubmVjdFwiLCBcImVycm9yXCIsIFwic29ja2V0XCIsIFwidGltZW91dFwiXTtcbnZhciBldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICBldmVudEhhbmRsZXJzW2V2ZW50XSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgdGhpcy5fcmVkaXJlY3RhYmxlLmVtaXQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9O1xufSk7XG5cbnZhciBJbnZhbGlkVXJsRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXG4gIFwiRVJSX0lOVkFMSURfVVJMXCIsXG4gIFwiSW52YWxpZCBVUkxcIixcbiAgVHlwZUVycm9yXG4pO1xuLy8gRXJyb3IgdHlwZXMgd2l0aCBjb2Rlc1xudmFyIFJlZGlyZWN0aW9uRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXG4gIFwiRVJSX0ZSX1JFRElSRUNUSU9OX0ZBSUxVUkVcIixcbiAgXCJSZWRpcmVjdGVkIHJlcXVlc3QgZmFpbGVkXCJcbik7XG52YXIgVG9vTWFueVJlZGlyZWN0c0Vycm9yID0gY3JlYXRlRXJyb3JUeXBlKFxuICBcIkVSUl9GUl9UT09fTUFOWV9SRURJUkVDVFNcIixcbiAgXCJNYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHMgZXhjZWVkZWRcIlxuKTtcbnZhciBNYXhCb2R5TGVuZ3RoRXhjZWVkZWRFcnJvciA9IGNyZWF0ZUVycm9yVHlwZShcbiAgXCJFUlJfRlJfTUFYX0JPRFlfTEVOR1RIX0VYQ0VFREVEXCIsXG4gIFwiUmVxdWVzdCBib2R5IGxhcmdlciB0aGFuIG1heEJvZHlMZW5ndGggbGltaXRcIlxuKTtcbnZhciBXcml0ZUFmdGVyRW5kRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXG4gIFwiRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkRcIixcbiAgXCJ3cml0ZSBhZnRlciBlbmRcIlxuKTtcblxuLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbnZhciBkZXN0cm95ID0gV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgfHwgbm9vcDtcblxuLy8gQW4gSFRUUChTKSByZXF1ZXN0IHRoYXQgY2FuIGJlIHJlZGlyZWN0ZWRcbmZ1bmN0aW9uIFJlZGlyZWN0YWJsZVJlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2VDYWxsYmFjaykge1xuICAvLyBJbml0aWFsaXplIHRoZSByZXF1ZXN0XG4gIFdyaXRhYmxlLmNhbGwodGhpcyk7XG4gIHRoaXMuX3Nhbml0aXplT3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gIHRoaXMuX2VuZGluZyA9IGZhbHNlO1xuICB0aGlzLl9yZWRpcmVjdENvdW50ID0gMDtcbiAgdGhpcy5fcmVkaXJlY3RzID0gW107XG4gIHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoID0gMDtcbiAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XG5cbiAgLy8gQXR0YWNoIGEgY2FsbGJhY2sgaWYgcGFzc2VkXG4gIGlmIChyZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbihcInJlc3BvbnNlXCIsIHJlc3BvbnNlQ2FsbGJhY2spO1xuICB9XG5cbiAgLy8gUmVhY3QgdG8gcmVzcG9uc2VzIG9mIG5hdGl2ZSByZXF1ZXN0c1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX29uTmF0aXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBzZWxmLl9wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gdGhlIGZpcnN0IHJlcXVlc3RcbiAgdGhpcy5fcGVyZm9ybVJlcXVlc3QoKTtcbn1cblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZS5wcm90b3R5cGUpO1xuXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVzdHJveVJlcXVlc3QodGhpcy5fY3VycmVudFJlcXVlc3QpO1xuICB0aGlzLl9jdXJyZW50UmVxdWVzdC5hYm9ydCgpO1xuICB0aGlzLmVtaXQoXCJhYm9ydFwiKTtcbn07XG5cblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgZGVzdHJveVJlcXVlc3QodGhpcy5fY3VycmVudFJlcXVlc3QsIGVycm9yKTtcbiAgZGVzdHJveS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBXcml0ZXMgYnVmZmVyZWQgZGF0YSB0byB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIC8vIFdyaXRpbmcgaXMgbm90IGFsbG93ZWQgaWYgZW5kIGhhcyBiZWVuIGNhbGxlZFxuICBpZiAodGhpcy5fZW5kaW5nKSB7XG4gICAgdGhyb3cgbmV3IFdyaXRlQWZ0ZXJFbmRFcnJvcigpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgaW5wdXQgYW5kIHNoaWZ0IHBhcmFtZXRlcnMgaWYgbmVjZXNzYXJ5XG4gIGlmICghaXNTdHJpbmcoZGF0YSkgJiYgIWlzQnVmZmVyKGRhdGEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGEgc2hvdWxkIGJlIGEgc3RyaW5nLCBCdWZmZXIgb3IgVWludDhBcnJheVwiKTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIC8vIElnbm9yZSBlbXB0eSBidWZmZXJzLCBzaW5jZSB3cml0aW5nIHRoZW0gZG9lc24ndCBpbnZva2UgdGhlIGNhbGxiYWNrXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMjIwNjZcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgLy8gT25seSB3cml0ZSB3aGVuIHdlIGRvbid0IGV4Y2VlZCB0aGUgbWF4aW11bSBib2R5IGxlbmd0aFxuICBpZiAodGhpcy5fcmVxdWVzdEJvZHlMZW5ndGggKyBkYXRhLmxlbmd0aCA8PSB0aGlzLl9vcHRpb25zLm1heEJvZHlMZW5ndGgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnMucHVzaCh7IGRhdGE6IGRhdGEsIGVuY29kaW5nOiBlbmNvZGluZyB9KTtcbiAgICB0aGlzLl9jdXJyZW50UmVxdWVzdC53cml0ZShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICB9XG4gIC8vIEVycm9yIHdoZW4gd2UgZXhjZWVkIHRoZSBtYXhpbXVtIGJvZHkgbGVuZ3RoXG4gIGVsc2Uge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBNYXhCb2R5TGVuZ3RoRXhjZWVkZWRFcnJvcigpKTtcbiAgICB0aGlzLmFib3J0KCk7XG4gIH1cbn07XG5cbi8vIEVuZHMgdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgLy8gU2hpZnQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnlcbiAgaWYgKGlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgZGF0YSA9IGVuY29kaW5nID0gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNhbGxiYWNrID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgLy8gV3JpdGUgZGF0YSBpZiBuZWVkZWQgYW5kIGVuZFxuICBpZiAoIWRhdGEpIHtcbiAgICB0aGlzLl9lbmRlZCA9IHRoaXMuX2VuZGluZyA9IHRydWU7XG4gICAgdGhpcy5fY3VycmVudFJlcXVlc3QuZW5kKG51bGwsIG51bGwsIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRSZXF1ZXN0ID0gdGhpcy5fY3VycmVudFJlcXVlc3Q7XG4gICAgdGhpcy53cml0ZShkYXRhLCBlbmNvZGluZywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fZW5kZWQgPSB0cnVlO1xuICAgICAgY3VycmVudFJlcXVlc3QuZW5kKG51bGwsIG51bGwsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbmRpbmcgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBTZXRzIGEgaGVhZGVyIHZhbHVlIG9uIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5fb3B0aW9ucy5oZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LnNldEhlYWRlcihuYW1lLCB2YWx1ZSk7XG59O1xuXG4vLyBDbGVhcnMgYSBoZWFkZXIgdmFsdWUgb24gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLl9vcHRpb25zLmhlYWRlcnNbbmFtZV07XG4gIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LnJlbW92ZUhlYWRlcihuYW1lKTtcbn07XG5cbi8vIEdsb2JhbCB0aW1lb3V0IGZvciBhbGwgdW5kZXJseWluZyByZXF1ZXN0c1xuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChtc2VjcywgY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIERlc3Ryb3lzIHRoZSBzb2NrZXQgb24gdGltZW91dFxuICBmdW5jdGlvbiBkZXN0cm95T25UaW1lb3V0KHNvY2tldCkge1xuICAgIHNvY2tldC5zZXRUaW1lb3V0KG1zZWNzKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHNvY2tldC5kZXN0cm95KTtcbiAgICBzb2NrZXQuYWRkTGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHNvY2tldC5kZXN0cm95KTtcbiAgfVxuXG4gIC8vIFNldHMgdXAgYSB0aW1lciB0byB0cmlnZ2VyIGEgdGltZW91dCBldmVudFxuICBmdW5jdGlvbiBzdGFydFRpbWVyKHNvY2tldCkge1xuICAgIGlmIChzZWxmLl90aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fdGltZW91dCk7XG4gICAgfVxuICAgIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdChcInRpbWVvdXRcIik7XG4gICAgICBjbGVhclRpbWVyKCk7XG4gICAgfSwgbXNlY3MpO1xuICAgIGRlc3Ryb3lPblRpbWVvdXQoc29ja2V0KTtcbiAgfVxuXG4gIC8vIFN0b3BzIGEgdGltZW91dCBmcm9tIHRyaWdnZXJpbmdcbiAgZnVuY3Rpb24gY2xlYXJUaW1lcigpIHtcbiAgICAvLyBDbGVhciB0aGUgdGltZW91dFxuICAgIGlmIChzZWxmLl90aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fdGltZW91dCk7XG4gICAgICBzZWxmLl90aW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBhbGwgYXR0YWNoZWQgbGlzdGVuZXJzXG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcImFib3J0XCIsIGNsZWFyVGltZXIpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBjbGVhclRpbWVyKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwicmVzcG9uc2VcIiwgY2xlYXJUaW1lcik7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIGNsZWFyVGltZXIpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcInRpbWVvdXRcIiwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAoIXNlbGYuc29ja2V0KSB7XG4gICAgICBzZWxmLl9jdXJyZW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcihcInNvY2tldFwiLCBzdGFydFRpbWVyKTtcbiAgICB9XG4gIH1cblxuICAvLyBBdHRhY2ggY2FsbGJhY2sgaWYgcGFzc2VkXG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMub24oXCJ0aW1lb3V0XCIsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IHRoZSB0aW1lciBpZiBvciB3aGVuIHRoZSBzb2NrZXQgaXMgb3BlbmVkXG4gIGlmICh0aGlzLnNvY2tldCkge1xuICAgIHN0YXJ0VGltZXIodGhpcy5zb2NrZXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0Lm9uY2UoXCJzb2NrZXRcIiwgc3RhcnRUaW1lcik7XG4gIH1cblxuICAvLyBDbGVhbiB1cCBvbiBldmVudHNcbiAgdGhpcy5vbihcInNvY2tldFwiLCBkZXN0cm95T25UaW1lb3V0KTtcbiAgdGhpcy5vbihcImFib3J0XCIsIGNsZWFyVGltZXIpO1xuICB0aGlzLm9uKFwiZXJyb3JcIiwgY2xlYXJUaW1lcik7XG4gIHRoaXMub24oXCJyZXNwb25zZVwiLCBjbGVhclRpbWVyKTtcbiAgdGhpcy5vbihcImNsb3NlXCIsIGNsZWFyVGltZXIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gUHJveHkgYWxsIG90aGVyIHB1YmxpYyBDbGllbnRSZXF1ZXN0IG1ldGhvZHNcbltcbiAgXCJmbHVzaEhlYWRlcnNcIiwgXCJnZXRIZWFkZXJcIixcbiAgXCJzZXROb0RlbGF5XCIsIFwic2V0U29ja2V0S2VlcEFsaXZlXCIsXG5dLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICBSZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFJlcXVlc3RbbWV0aG9kXShhLCBiKTtcbiAgfTtcbn0pO1xuXG4vLyBQcm94eSBhbGwgcHVibGljIENsaWVudFJlcXVlc3QgcHJvcGVydGllc1xuW1wiYWJvcnRlZFwiLCBcImNvbm5lY3Rpb25cIiwgXCJzb2NrZXRcIl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLCBwcm9wZXJ0eSwge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3VycmVudFJlcXVlc3RbcHJvcGVydHldOyB9LFxuICB9KTtcbn0pO1xuXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5fc2FuaXRpemVPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gRW5zdXJlIGhlYWRlcnMgYXJlIGFsd2F5cyBwcmVzZW50XG4gIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0ge307XG4gIH1cblxuICAvLyBTaW5jZSBodHRwLnJlcXVlc3QgdHJlYXRzIGhvc3QgYXMgYW4gYWxpYXMgb2YgaG9zdG5hbWUsXG4gIC8vIGJ1dCB0aGUgdXJsIG1vZHVsZSBpbnRlcnByZXRzIGhvc3QgYXMgaG9zdG5hbWUgcGx1cyBwb3J0LFxuICAvLyBlbGltaW5hdGUgdGhlIGhvc3QgcHJvcGVydHkgdG8gYXZvaWQgY29uZnVzaW9uLlxuICBpZiAob3B0aW9ucy5ob3N0KSB7XG4gICAgLy8gVXNlIGhvc3RuYW1lIGlmIHNldCwgYmVjYXVzZSBpdCBoYXMgcHJlY2VkZW5jZVxuICAgIGlmICghb3B0aW9ucy5ob3N0bmFtZSkge1xuICAgICAgb3B0aW9ucy5ob3N0bmFtZSA9IG9wdGlvbnMuaG9zdDtcbiAgICB9XG4gICAgZGVsZXRlIG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIC8vIENvbXBsZXRlIHRoZSBVUkwgb2JqZWN0IHdoZW4gbmVjZXNzYXJ5XG4gIGlmICghb3B0aW9ucy5wYXRobmFtZSAmJiBvcHRpb25zLnBhdGgpIHtcbiAgICB2YXIgc2VhcmNoUG9zID0gb3B0aW9ucy5wYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hQb3MgPCAwKSB7XG4gICAgICBvcHRpb25zLnBhdGhuYW1lID0gb3B0aW9ucy5wYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9wdGlvbnMucGF0aG5hbWUgPSBvcHRpb25zLnBhdGguc3Vic3RyaW5nKDAsIHNlYXJjaFBvcyk7XG4gICAgICBvcHRpb25zLnNlYXJjaCA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoc2VhcmNoUG9zKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLy8gRXhlY3V0ZXMgdGhlIG5leHQgbmF0aXZlIHJlcXVlc3QgKGluaXRpYWwgb3IgcmVkaXJlY3QpXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5fcGVyZm9ybVJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIExvYWQgdGhlIG5hdGl2ZSBwcm90b2NvbFxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLl9vcHRpb25zLnByb3RvY29sO1xuICB2YXIgbmF0aXZlUHJvdG9jb2wgPSB0aGlzLl9vcHRpb25zLm5hdGl2ZVByb3RvY29sc1twcm90b2NvbF07XG4gIGlmICghbmF0aXZlUHJvdG9jb2wpIHtcbiAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgcHJvdG9jb2wgXCIgKyBwcm90b2NvbCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIHNwZWNpZmllZCwgdXNlIHRoZSBhZ2VudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm90b2NvbFxuICAvLyAoSFRUUCBhbmQgSFRUUFMgdXNlIGRpZmZlcmVudCB0eXBlcyBvZiBhZ2VudHMpXG4gIGlmICh0aGlzLl9vcHRpb25zLmFnZW50cykge1xuICAgIHZhciBzY2hlbWUgPSBwcm90b2NvbC5zbGljZSgwLCAtMSk7XG4gICAgdGhpcy5fb3B0aW9ucy5hZ2VudCA9IHRoaXMuX29wdGlvbnMuYWdlbnRzW3NjaGVtZV07XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIG5hdGl2ZSByZXF1ZXN0IGFuZCBzZXQgdXAgaXRzIGV2ZW50IGhhbmRsZXJzXG4gIHZhciByZXF1ZXN0ID0gdGhpcy5fY3VycmVudFJlcXVlc3QgPVxuICAgICAgICBuYXRpdmVQcm90b2NvbC5yZXF1ZXN0KHRoaXMuX29wdGlvbnMsIHRoaXMuX29uTmF0aXZlUmVzcG9uc2UpO1xuICByZXF1ZXN0Ll9yZWRpcmVjdGFibGUgPSB0aGlzO1xuICBmb3IgKHZhciBldmVudCBvZiBldmVudHMpIHtcbiAgICByZXF1ZXN0Lm9uKGV2ZW50LCBldmVudEhhbmRsZXJzW2V2ZW50XSk7XG4gIH1cblxuICAvLyBSRkM3MjMwwqc1LjMuMTogV2hlbiBtYWtpbmcgYSByZXF1ZXN0IGRpcmVjdGx5IHRvIGFuIG9yaWdpbiBzZXJ2ZXIsIFvigKZdXG4gIC8vIGEgY2xpZW50IE1VU1Qgc2VuZCBvbmx5IHRoZSBhYnNvbHV0ZSBwYXRoIFvigKZdIGFzIHRoZSByZXF1ZXN0LXRhcmdldC5cbiAgdGhpcy5fY3VycmVudFVybCA9IC9eXFwvLy50ZXN0KHRoaXMuX29wdGlvbnMucGF0aCkgP1xuICAgIHVybC5mb3JtYXQodGhpcy5fb3B0aW9ucykgOlxuICAgIC8vIFdoZW4gbWFraW5nIGEgcmVxdWVzdCB0byBhIHByb3h5LCBb4oCmXVxuICAgIC8vIGEgY2xpZW50IE1VU1Qgc2VuZCB0aGUgdGFyZ2V0IFVSSSBpbiBhYnNvbHV0ZS1mb3JtIFvigKZdLlxuICAgIHRoaXMuX29wdGlvbnMucGF0aDtcblxuICAvLyBFbmQgYSByZWRpcmVjdGVkIHJlcXVlc3RcbiAgLy8gKFRoZSBmaXJzdCByZXF1ZXN0IG11c3QgYmUgZW5kZWQgZXhwbGljaXRseSB3aXRoIFJlZGlyZWN0YWJsZVJlcXVlc3QjZW5kKVxuICBpZiAodGhpcy5faXNSZWRpcmVjdCkge1xuICAgIC8vIFdyaXRlIHRoZSByZXF1ZXN0IGVudGl0eSBhbmQgZW5kXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYnVmZmVycyA9IHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycztcbiAgICAoZnVuY3Rpb24gd3JpdGVOZXh0KGVycm9yKSB7XG4gICAgICAvLyBPbmx5IHdyaXRlIGlmIHRoaXMgcmVxdWVzdCBoYXMgbm90IGJlZW4gcmVkaXJlY3RlZCB5ZXRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocmVxdWVzdCA9PT0gc2VsZi5fY3VycmVudFJlcXVlc3QpIHtcbiAgICAgICAgLy8gUmVwb3J0IGFueSB3cml0ZSBlcnJvcnNcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSB0aGUgbmV4dCBidWZmZXIgaWYgdGhlcmUgYXJlIHN0aWxsIGxlZnRcbiAgICAgICAgZWxzZSBpZiAoaSA8IGJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbaSsrXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmICghcmVxdWVzdC5maW5pc2hlZCkge1xuICAgICAgICAgICAgcmVxdWVzdC53cml0ZShidWZmZXIuZGF0YSwgYnVmZmVyLmVuY29kaW5nLCB3cml0ZU5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbmQgdGhlIHJlcXVlc3QgaWYgYGVuZGAgaGFzIGJlZW4gY2FsbGVkIG9uIHVzXG4gICAgICAgIGVsc2UgaWYgKHNlbGYuX2VuZGVkKSB7XG4gICAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0oKSk7XG4gIH1cbn07XG5cbi8vIFByb2Nlc3NlcyBhIHJlc3BvbnNlIGZyb20gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLl9wcm9jZXNzUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgLy8gU3RvcmUgdGhlIHJlZGlyZWN0ZWQgcmVzcG9uc2VcbiAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICBpZiAodGhpcy5fb3B0aW9ucy50cmFja1JlZGlyZWN0cykge1xuICAgIHRoaXMuX3JlZGlyZWN0cy5wdXNoKHtcbiAgICAgIHVybDogdGhpcy5fY3VycmVudFVybCxcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUkZDNzIzMcKnNi40OiBUaGUgM3h4IChSZWRpcmVjdGlvbikgY2xhc3Mgb2Ygc3RhdHVzIGNvZGUgaW5kaWNhdGVzXG4gIC8vIHRoYXQgZnVydGhlciBhY3Rpb24gbmVlZHMgdG8gYmUgdGFrZW4gYnkgdGhlIHVzZXIgYWdlbnQgaW4gb3JkZXIgdG9cbiAgLy8gZnVsZmlsbCB0aGUgcmVxdWVzdC4gSWYgYSBMb2NhdGlvbiBoZWFkZXIgZmllbGQgaXMgcHJvdmlkZWQsXG4gIC8vIHRoZSB1c2VyIGFnZW50IE1BWSBhdXRvbWF0aWNhbGx5IHJlZGlyZWN0IGl0cyByZXF1ZXN0IHRvIHRoZSBVUklcbiAgLy8gcmVmZXJlbmNlZCBieSB0aGUgTG9jYXRpb24gZmllbGQgdmFsdWUsXG4gIC8vIGV2ZW4gaWYgdGhlIHNwZWNpZmljIHN0YXR1cyBjb2RlIGlzIG5vdCB1bmRlcnN0b29kLlxuXG4gIC8vIElmIHRoZSByZXNwb25zZSBpcyBub3QgYSByZWRpcmVjdDsgcmV0dXJuIGl0IGFzLWlzXG4gIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XG4gIGlmICghbG9jYXRpb24gfHwgdGhpcy5fb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgPT09IGZhbHNlIHx8XG4gICAgICBzdGF0dXNDb2RlIDwgMzAwIHx8IHN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgcmVzcG9uc2UucmVzcG9uc2VVcmwgPSB0aGlzLl9jdXJyZW50VXJsO1xuICAgIHJlc3BvbnNlLnJlZGlyZWN0cyA9IHRoaXMuX3JlZGlyZWN0cztcbiAgICB0aGlzLmVtaXQoXCJyZXNwb25zZVwiLCByZXNwb25zZSk7XG5cbiAgICAvLyBDbGVhbiB1cFxuICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZSByZXNwb25zZSBpcyBhIHJlZGlyZWN0LCBzbyBhYm9ydCB0aGUgY3VycmVudCByZXF1ZXN0XG4gIGRlc3Ryb3lSZXF1ZXN0KHRoaXMuX2N1cnJlbnRSZXF1ZXN0KTtcbiAgLy8gRGlzY2FyZCB0aGUgcmVtYWluZGVyIG9mIHRoZSByZXNwb25zZSB0byBhdm9pZCB3YWl0aW5nIGZvciBkYXRhXG4gIHJlc3BvbnNlLmRlc3Ryb3koKTtcblxuICAvLyBSRkM3MjMxwqc2LjQ6IEEgY2xpZW50IFNIT1VMRCBkZXRlY3QgYW5kIGludGVydmVuZVxuICAvLyBpbiBjeWNsaWNhbCByZWRpcmVjdGlvbnMgKGkuZS4sIFwiaW5maW5pdGVcIiByZWRpcmVjdGlvbiBsb29wcykuXG4gIGlmICgrK3RoaXMuX3JlZGlyZWN0Q291bnQgPiB0aGlzLl9vcHRpb25zLm1heFJlZGlyZWN0cykge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBUb29NYW55UmVkaXJlY3RzRXJyb3IoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gU3RvcmUgdGhlIHJlcXVlc3QgaGVhZGVycyBpZiBhcHBsaWNhYmxlXG4gIHZhciByZXF1ZXN0SGVhZGVycztcbiAgdmFyIGJlZm9yZVJlZGlyZWN0ID0gdGhpcy5fb3B0aW9ucy5iZWZvcmVSZWRpcmVjdDtcbiAgaWYgKGJlZm9yZVJlZGlyZWN0KSB7XG4gICAgcmVxdWVzdEhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIC8vIFRoZSBIb3N0IGhlYWRlciB3YXMgc2V0IGJ5IG5hdGl2ZVByb3RvY29sLnJlcXVlc3RcbiAgICAgIEhvc3Q6IHJlc3BvbnNlLnJlcS5nZXRIZWFkZXIoXCJob3N0XCIpLFxuICAgIH0sIHRoaXMuX29wdGlvbnMuaGVhZGVycyk7XG4gIH1cblxuICAvLyBSRkM3MjMxwqc2LjQ6IEF1dG9tYXRpYyByZWRpcmVjdGlvbiBuZWVkcyB0byBkb25lIHdpdGhcbiAgLy8gY2FyZSBmb3IgbWV0aG9kcyBub3Qga25vd24gdG8gYmUgc2FmZSwgW+KApl1cbiAgLy8gUkZDNzIzMcKnNi40LjLigJMzOiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCBhIHVzZXIgYWdlbnQgTUFZIGNoYW5nZVxuICAvLyB0aGUgcmVxdWVzdCBtZXRob2QgZnJvbSBQT1NUIHRvIEdFVCBmb3IgdGhlIHN1YnNlcXVlbnQgcmVxdWVzdC5cbiAgdmFyIG1ldGhvZCA9IHRoaXMuX29wdGlvbnMubWV0aG9kO1xuICBpZiAoKHN0YXR1c0NvZGUgPT09IDMwMSB8fCBzdGF0dXNDb2RlID09PSAzMDIpICYmIHRoaXMuX29wdGlvbnMubWV0aG9kID09PSBcIlBPU1RcIiB8fFxuICAgICAgLy8gUkZDNzIzMcKnNi40LjQ6IFRoZSAzMDMgKFNlZSBPdGhlcikgc3RhdHVzIGNvZGUgaW5kaWNhdGVzIHRoYXRcbiAgICAgIC8vIHRoZSBzZXJ2ZXIgaXMgcmVkaXJlY3RpbmcgdGhlIHVzZXIgYWdlbnQgdG8gYSBkaWZmZXJlbnQgcmVzb3VyY2UgW+KApl1cbiAgICAgIC8vIEEgdXNlciBhZ2VudCBjYW4gcGVyZm9ybSBhIHJldHJpZXZhbCByZXF1ZXN0IHRhcmdldGluZyB0aGF0IFVSSVxuICAgICAgLy8gKGEgR0VUIG9yIEhFQUQgcmVxdWVzdCBpZiB1c2luZyBIVFRQKSBb4oCmXVxuICAgICAgKHN0YXR1c0NvZGUgPT09IDMwMykgJiYgIS9eKD86R0VUfEhFQUQpJC8udGVzdCh0aGlzLl9vcHRpb25zLm1ldGhvZCkpIHtcbiAgICB0aGlzLl9vcHRpb25zLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgLy8gRHJvcCBhIHBvc3NpYmxlIGVudGl0eSBhbmQgaGVhZGVycyByZWxhdGVkIHRvIGl0XG4gICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XG4gICAgcmVtb3ZlTWF0Y2hpbmdIZWFkZXJzKC9eY29udGVudC0vaSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTtcbiAgfVxuXG4gIC8vIERyb3AgdGhlIEhvc3QgaGVhZGVyLCBhcyB0aGUgcmVkaXJlY3QgbWlnaHQgbGVhZCB0byBhIGRpZmZlcmVudCBob3N0XG4gIHZhciBjdXJyZW50SG9zdEhlYWRlciA9IHJlbW92ZU1hdGNoaW5nSGVhZGVycygvXmhvc3QkL2ksIHRoaXMuX29wdGlvbnMuaGVhZGVycyk7XG5cbiAgLy8gSWYgdGhlIHJlZGlyZWN0IGlzIHJlbGF0aXZlLCBjYXJyeSBvdmVyIHRoZSBob3N0IG9mIHRoZSBsYXN0IHJlcXVlc3RcbiAgdmFyIGN1cnJlbnRVcmxQYXJ0cyA9IHVybC5wYXJzZSh0aGlzLl9jdXJyZW50VXJsKTtcbiAgdmFyIGN1cnJlbnRIb3N0ID0gY3VycmVudEhvc3RIZWFkZXIgfHwgY3VycmVudFVybFBhcnRzLmhvc3Q7XG4gIHZhciBjdXJyZW50VXJsID0gL15cXHcrOi8udGVzdChsb2NhdGlvbikgPyB0aGlzLl9jdXJyZW50VXJsIDpcbiAgICB1cmwuZm9ybWF0KE9iamVjdC5hc3NpZ24oY3VycmVudFVybFBhcnRzLCB7IGhvc3Q6IGN1cnJlbnRIb3N0IH0pKTtcblxuICAvLyBEZXRlcm1pbmUgdGhlIFVSTCBvZiB0aGUgcmVkaXJlY3Rpb25cbiAgdmFyIHJlZGlyZWN0VXJsO1xuICB0cnkge1xuICAgIHJlZGlyZWN0VXJsID0gdXJsLnJlc29sdmUoY3VycmVudFVybCwgbG9jYXRpb24pO1xuICB9XG4gIGNhdGNoIChjYXVzZSkge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBSZWRpcmVjdGlvbkVycm9yKHsgY2F1c2U6IGNhdXNlIH0pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIHJlZGlyZWN0ZWQgcmVxdWVzdFxuICBkZWJ1ZyhcInJlZGlyZWN0aW5nIHRvXCIsIHJlZGlyZWN0VXJsKTtcbiAgdGhpcy5faXNSZWRpcmVjdCA9IHRydWU7XG4gIHZhciByZWRpcmVjdFVybFBhcnRzID0gdXJsLnBhcnNlKHJlZGlyZWN0VXJsKTtcbiAgT2JqZWN0LmFzc2lnbih0aGlzLl9vcHRpb25zLCByZWRpcmVjdFVybFBhcnRzKTtcblxuICAvLyBEcm9wIGNvbmZpZGVudGlhbCBoZWFkZXJzIHdoZW4gcmVkaXJlY3RpbmcgdG8gYSBsZXNzIHNlY3VyZSBwcm90b2NvbFxuICAvLyBvciB0byBhIGRpZmZlcmVudCBkb21haW4gdGhhdCBpcyBub3QgYSBzdXBlcmRvbWFpblxuICBpZiAocmVkaXJlY3RVcmxQYXJ0cy5wcm90b2NvbCAhPT0gY3VycmVudFVybFBhcnRzLnByb3RvY29sICYmXG4gICAgIHJlZGlyZWN0VXJsUGFydHMucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIgfHxcbiAgICAgcmVkaXJlY3RVcmxQYXJ0cy5ob3N0ICE9PSBjdXJyZW50SG9zdCAmJlxuICAgICAhaXNTdWJkb21haW4ocmVkaXJlY3RVcmxQYXJ0cy5ob3N0LCBjdXJyZW50SG9zdCkpIHtcbiAgICByZW1vdmVNYXRjaGluZ0hlYWRlcnMoL14oPzphdXRob3JpemF0aW9ufGNvb2tpZSkkL2ksIHRoaXMuX29wdGlvbnMuaGVhZGVycyk7XG4gIH1cblxuICAvLyBFdmFsdWF0ZSB0aGUgYmVmb3JlUmVkaXJlY3QgY2FsbGJhY2tcbiAgaWYgKGlzRnVuY3Rpb24oYmVmb3JlUmVkaXJlY3QpKSB7XG4gICAgdmFyIHJlc3BvbnNlRGV0YWlscyA9IHtcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgIH07XG4gICAgdmFyIHJlcXVlc3REZXRhaWxzID0ge1xuICAgICAgdXJsOiBjdXJyZW50VXJsLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBoZWFkZXJzOiByZXF1ZXN0SGVhZGVycyxcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBiZWZvcmVSZWRpcmVjdCh0aGlzLl9vcHRpb25zLCByZXNwb25zZURldGFpbHMsIHJlcXVlc3REZXRhaWxzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2FuaXRpemVPcHRpb25zKHRoaXMuX29wdGlvbnMpO1xuICB9XG5cbiAgLy8gUGVyZm9ybSB0aGUgcmVkaXJlY3RlZCByZXF1ZXN0XG4gIHRyeSB7XG4gICAgdGhpcy5fcGVyZm9ybVJlcXVlc3QoKTtcbiAgfVxuICBjYXRjaCAoY2F1c2UpIHtcbiAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgUmVkaXJlY3Rpb25FcnJvcih7IGNhdXNlOiBjYXVzZSB9KSk7XG4gIH1cbn07XG5cbi8vIFdyYXBzIHRoZSBrZXkvdmFsdWUgb2JqZWN0IG9mIHByb3RvY29scyB3aXRoIHJlZGlyZWN0IGZ1bmN0aW9uYWxpdHlcbmZ1bmN0aW9uIHdyYXAocHJvdG9jb2xzKSB7XG4gIC8vIERlZmF1bHQgc2V0dGluZ3NcbiAgdmFyIGV4cG9ydHMgPSB7XG4gICAgbWF4UmVkaXJlY3RzOiAyMSxcbiAgICBtYXhCb2R5TGVuZ3RoOiAxMCAqIDEwMjQgKiAxMDI0LFxuICB9O1xuXG4gIC8vIFdyYXAgZWFjaCBwcm90b2NvbFxuICB2YXIgbmF0aXZlUHJvdG9jb2xzID0ge307XG4gIE9iamVjdC5rZXlzKHByb3RvY29scykuZm9yRWFjaChmdW5jdGlvbiAoc2NoZW1lKSB7XG4gICAgdmFyIHByb3RvY29sID0gc2NoZW1lICsgXCI6XCI7XG4gICAgdmFyIG5hdGl2ZVByb3RvY29sID0gbmF0aXZlUHJvdG9jb2xzW3Byb3RvY29sXSA9IHByb3RvY29sc1tzY2hlbWVdO1xuICAgIHZhciB3cmFwcGVkUHJvdG9jb2wgPSBleHBvcnRzW3NjaGVtZV0gPSBPYmplY3QuY3JlYXRlKG5hdGl2ZVByb3RvY29sKTtcblxuICAgIC8vIEV4ZWN1dGVzIGEgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xuICAgIGZ1bmN0aW9uIHJlcXVlc3QoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBQYXJzZSBwYXJhbWV0ZXJzXG4gICAgICBpZiAoaXNTdHJpbmcoaW5wdXQpKSB7XG4gICAgICAgIHZhciBwYXJzZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkID0gdXJsVG9PcHRpb25zKG5ldyBVUkwoaW5wdXQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBwYXJzZWQgPSB1cmwucGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTdHJpbmcocGFyc2VkLnByb3RvY29sKSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVXJsRXJyb3IoeyBpbnB1dCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKFVSTCAmJiAoaW5wdXQgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIGlucHV0ID0gdXJsVG9PcHRpb25zKGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBpbnB1dDtcbiAgICAgICAgaW5wdXQgPSB7IHByb3RvY29sOiBwcm90b2NvbCB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG1heFJlZGlyZWN0czogZXhwb3J0cy5tYXhSZWRpcmVjdHMsXG4gICAgICAgIG1heEJvZHlMZW5ndGg6IGV4cG9ydHMubWF4Qm9keUxlbmd0aCxcbiAgICAgIH0sIGlucHV0LCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMubmF0aXZlUHJvdG9jb2xzID0gbmF0aXZlUHJvdG9jb2xzO1xuICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLmhvc3QpICYmICFpc1N0cmluZyhvcHRpb25zLmhvc3RuYW1lKSkge1xuICAgICAgICBvcHRpb25zLmhvc3RuYW1lID0gXCI6OjFcIjtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0LmVxdWFsKG9wdGlvbnMucHJvdG9jb2wsIHByb3RvY29sLCBcInByb3RvY29sIG1pc21hdGNoXCIpO1xuICAgICAgZGVidWcoXCJvcHRpb25zXCIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG5ldyBSZWRpcmVjdGFibGVSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvLyBFeGVjdXRlcyBhIEdFVCByZXF1ZXN0LCBmb2xsb3dpbmcgcmVkaXJlY3RzXG4gICAgZnVuY3Rpb24gZ2V0KGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHdyYXBwZWRSZXF1ZXN0ID0gd3JhcHBlZFByb3RvY29sLnJlcXVlc3QoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIHdyYXBwZWRSZXF1ZXN0LmVuZCgpO1xuICAgICAgcmV0dXJuIHdyYXBwZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSB0aGUgcHJvcGVydGllcyBvbiB0aGUgd3JhcHBlZCBwcm90b2NvbFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWRQcm90b2NvbCwge1xuICAgICAgcmVxdWVzdDogeyB2YWx1ZTogcmVxdWVzdCwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgICAgZ2V0OiB7IHZhbHVlOiBnZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBleHBvcnRzO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHsgLyogZW1wdHkgKi8gfVxuXG4vLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvdXJsLmpzXG5mdW5jdGlvbiB1cmxUb09wdGlvbnModXJsT2JqZWN0KSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIHByb3RvY29sOiB1cmxPYmplY3QucHJvdG9jb2wsXG4gICAgaG9zdG5hbWU6IHVybE9iamVjdC5ob3N0bmFtZS5zdGFydHNXaXRoKFwiW1wiKSA/XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdXJsT2JqZWN0Lmhvc3RuYW1lLnNsaWNlKDEsIC0xKSA6XG4gICAgICB1cmxPYmplY3QuaG9zdG5hbWUsXG4gICAgaGFzaDogdXJsT2JqZWN0Lmhhc2gsXG4gICAgc2VhcmNoOiB1cmxPYmplY3Quc2VhcmNoLFxuICAgIHBhdGhuYW1lOiB1cmxPYmplY3QucGF0aG5hbWUsXG4gICAgcGF0aDogdXJsT2JqZWN0LnBhdGhuYW1lICsgdXJsT2JqZWN0LnNlYXJjaCxcbiAgICBocmVmOiB1cmxPYmplY3QuaHJlZixcbiAgfTtcbiAgaWYgKHVybE9iamVjdC5wb3J0ICE9PSBcIlwiKSB7XG4gICAgb3B0aW9ucy5wb3J0ID0gTnVtYmVyKHVybE9iamVjdC5wb3J0KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTWF0Y2hpbmdIZWFkZXJzKHJlZ2V4LCBoZWFkZXJzKSB7XG4gIHZhciBsYXN0VmFsdWU7XG4gIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgaWYgKHJlZ2V4LnRlc3QoaGVhZGVyKSkge1xuICAgICAgbGFzdFZhbHVlID0gaGVhZGVyc1toZWFkZXJdO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChsYXN0VmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGxhc3RWYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikgP1xuICAgIHVuZGVmaW5lZCA6IFN0cmluZyhsYXN0VmFsdWUpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIGJhc2VDbGFzcykge1xuICAvLyBDcmVhdGUgY29uc3RydWN0b3JcbiAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IocHJvcGVydGllcykge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcGVydGllcyB8fCB7fSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNhdXNlID8gbWVzc2FnZSArIFwiOiBcIiArIHRoaXMuY2F1c2UubWVzc2FnZSA6IG1lc3NhZ2U7XG4gIH1cblxuICAvLyBBdHRhY2ggY29uc3RydWN0b3IgYW5kIHNldCBkZWZhdWx0IHByb3BlcnRpZXNcbiAgQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gbmV3IChiYXNlQ2xhc3MgfHwgRXJyb3IpKCk7XG4gIEN1c3RvbUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1c3RvbUVycm9yO1xuICBDdXN0b21FcnJvci5wcm90b3R5cGUubmFtZSA9IFwiRXJyb3IgW1wiICsgY29kZSArIFwiXVwiO1xuICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lSZXF1ZXN0KHJlcXVlc3QsIGVycm9yKSB7XG4gIGZvciAodmFyIGV2ZW50IG9mIGV2ZW50cykge1xuICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGV2ZW50SGFuZGxlcnNbZXZlbnRdKTtcbiAgfVxuICByZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgbm9vcCk7XG4gIHJlcXVlc3QuZGVzdHJveShlcnJvcik7XG59XG5cbmZ1bmN0aW9uIGlzU3ViZG9tYWluKHN1YmRvbWFpbiwgZG9tYWluKSB7XG4gIGFzc2VydChpc1N0cmluZyhzdWJkb21haW4pICYmIGlzU3RyaW5nKGRvbWFpbikpO1xuICB2YXIgZG90ID0gc3ViZG9tYWluLmxlbmd0aCAtIGRvbWFpbi5sZW5ndGggLSAxO1xuICByZXR1cm4gZG90ID4gMCAmJiBzdWJkb21haW5bZG90XSA9PT0gXCIuXCIgJiYgc3ViZG9tYWluLmVuZHNXaXRoKGRvbWFpbik7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIChcImxlbmd0aFwiIGluIHZhbHVlKTtcbn1cblxuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB3cmFwKHsgaHR0cDogaHR0cCwgaHR0cHM6IGh0dHBzIH0pO1xubW9kdWxlLmV4cG9ydHMud3JhcCA9IHdyYXA7XG4iXSwibmFtZXMiOlsidXJsIiwicmVxdWlyZSIsIlVSTCIsImh0dHAiLCJodHRwcyIsIldyaXRhYmxlIiwiYXNzZXJ0IiwiZGVidWciLCJldmVudHMiLCJldmVudEhhbmRsZXJzIiwiT2JqZWN0IiwiY3JlYXRlIiwiZm9yRWFjaCIsImV2ZW50IiwiYXJnMSIsImFyZzIiLCJhcmczIiwiX3JlZGlyZWN0YWJsZSIsImVtaXQiLCJJbnZhbGlkVXJsRXJyb3IiLCJjcmVhdGVFcnJvclR5cGUiLCJUeXBlRXJyb3IiLCJSZWRpcmVjdGlvbkVycm9yIiwiVG9vTWFueVJlZGlyZWN0c0Vycm9yIiwiTWF4Qm9keUxlbmd0aEV4Y2VlZGVkRXJyb3IiLCJXcml0ZUFmdGVyRW5kRXJyb3IiLCJkZXN0cm95IiwicHJvdG90eXBlIiwibm9vcCIsIlJlZGlyZWN0YWJsZVJlcXVlc3QiLCJvcHRpb25zIiwicmVzcG9uc2VDYWxsYmFjayIsImNhbGwiLCJfc2FuaXRpemVPcHRpb25zIiwiX29wdGlvbnMiLCJfZW5kZWQiLCJfZW5kaW5nIiwiX3JlZGlyZWN0Q291bnQiLCJfcmVkaXJlY3RzIiwiX3JlcXVlc3RCb2R5TGVuZ3RoIiwiX3JlcXVlc3RCb2R5QnVmZmVycyIsIm9uIiwic2VsZiIsIl9vbk5hdGl2ZVJlc3BvbnNlIiwicmVzcG9uc2UiLCJfcHJvY2Vzc1Jlc3BvbnNlIiwiX3BlcmZvcm1SZXF1ZXN0IiwiYWJvcnQiLCJkZXN0cm95UmVxdWVzdCIsIl9jdXJyZW50UmVxdWVzdCIsImVycm9yIiwid3JpdGUiLCJkYXRhIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsImlzU3RyaW5nIiwiaXNCdWZmZXIiLCJpc0Z1bmN0aW9uIiwibGVuZ3RoIiwibWF4Qm9keUxlbmd0aCIsInB1c2giLCJlbmQiLCJjdXJyZW50UmVxdWVzdCIsInNldEhlYWRlciIsIm5hbWUiLCJ2YWx1ZSIsImhlYWRlcnMiLCJyZW1vdmVIZWFkZXIiLCJzZXRUaW1lb3V0IiwibXNlY3MiLCJkZXN0cm95T25UaW1lb3V0Iiwic29ja2V0IiwicmVtb3ZlTGlzdGVuZXIiLCJhZGRMaXN0ZW5lciIsInN0YXJ0VGltZXIiLCJfdGltZW91dCIsImNsZWFyVGltZW91dCIsImNsZWFyVGltZXIiLCJvbmNlIiwibWV0aG9kIiwiYSIsImIiLCJwcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiaG9zdCIsImhvc3RuYW1lIiwicGF0aG5hbWUiLCJwYXRoIiwic2VhcmNoUG9zIiwiaW5kZXhPZiIsInN1YnN0cmluZyIsInNlYXJjaCIsInByb3RvY29sIiwibmF0aXZlUHJvdG9jb2wiLCJuYXRpdmVQcm90b2NvbHMiLCJhZ2VudHMiLCJzY2hlbWUiLCJzbGljZSIsImFnZW50IiwicmVxdWVzdCIsIl9jdXJyZW50VXJsIiwidGVzdCIsImZvcm1hdCIsIl9pc1JlZGlyZWN0IiwiaSIsImJ1ZmZlcnMiLCJ3cml0ZU5leHQiLCJidWZmZXIiLCJmaW5pc2hlZCIsInN0YXR1c0NvZGUiLCJ0cmFja1JlZGlyZWN0cyIsImxvY2F0aW9uIiwiZm9sbG93UmVkaXJlY3RzIiwicmVzcG9uc2VVcmwiLCJyZWRpcmVjdHMiLCJtYXhSZWRpcmVjdHMiLCJyZXF1ZXN0SGVhZGVycyIsImJlZm9yZVJlZGlyZWN0IiwiYXNzaWduIiwiSG9zdCIsInJlcSIsImdldEhlYWRlciIsInJlbW92ZU1hdGNoaW5nSGVhZGVycyIsImN1cnJlbnRIb3N0SGVhZGVyIiwiY3VycmVudFVybFBhcnRzIiwicGFyc2UiLCJjdXJyZW50SG9zdCIsImN1cnJlbnRVcmwiLCJyZWRpcmVjdFVybCIsInJlc29sdmUiLCJjYXVzZSIsInJlZGlyZWN0VXJsUGFydHMiLCJpc1N1YmRvbWFpbiIsInJlc3BvbnNlRGV0YWlscyIsInJlcXVlc3REZXRhaWxzIiwiZXJyIiwid3JhcCIsInByb3RvY29scyIsImV4cG9ydHMiLCJrZXlzIiwid3JhcHBlZFByb3RvY29sIiwiaW5wdXQiLCJwYXJzZWQiLCJ1cmxUb09wdGlvbnMiLCJlcXVhbCIsIndyYXBwZWRSZXF1ZXN0IiwiZGVmaW5lUHJvcGVydGllcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInVybE9iamVjdCIsInN0YXJ0c1dpdGgiLCJoYXNoIiwiaHJlZiIsInBvcnQiLCJOdW1iZXIiLCJyZWdleCIsImxhc3RWYWx1ZSIsImhlYWRlciIsInVuZGVmaW5lZCIsIlN0cmluZyIsInRyaW0iLCJjb2RlIiwibWVzc2FnZSIsImJhc2VDbGFzcyIsIkN1c3RvbUVycm9yIiwicHJvcGVydGllcyIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjb25zdHJ1Y3RvciIsInN1YmRvbWFpbiIsImRvbWFpbiIsImRvdCIsImVuZHNXaXRoIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/follow-redirects/index.js\n");

/***/ })

};
;